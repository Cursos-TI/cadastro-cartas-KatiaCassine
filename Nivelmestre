#include <stdio.h>
#include <string.h>

#define MAX_CARTAS 8

/* Enumerações para atributos (usadas nos menus) */
typedef enum {
    ATR_NULO = 0,
    ATR_POPULACAO = 1,
    ATR_AREA = 2,
    ATR_PIB = 3,
    ATR_PONTOS_TURISTICOS = 4,
    ATR_DENSIDADE = 5,
    ATR_PIB_PER_CAPITA = 6
} Atributo;

/* Estrutura que representa uma carta */
typedef struct {
    char estado[6];
    char codigo[8];
    char nomeCidade[64];
    long long populacao; /* inteiro grande */
    double area;         /* km^2 */
    double pib;          /* unidades monetárias (ex.: reais) */
    int pontosTuristicos;
    double densidade;    /* populacao / area */
    double pibPerCapita; /* pib / populacao */
} Carta;

/* Protótipos */
void carregaCartasPadrao(Carta cartas[], int *n);
void calculaDerivados(Carta *c);
void exibeCartaResumo(const Carta *c, int index);
void exibeTodasCartas(const Carta cartas[], int n);
const char* nomeAtributo(int a);
double valorAtributoDouble(const Carta *c, int a);
int comparaUmAtributo(const Carta *c1, const Carta *c2, int a);
int leInteiroSeguro(const char *prompt, int min, int max);
void limpaEntrada();

/* -------------------------
   Implementação
   ------------------------- */

/* Carrega as cartas fixas (valores ilustrativos; mantidos como "do código original") */
void carregaCartasPadrao(Carta cartas[], int *n) {
    *n = MAX_CARTAS;

    strcpy(cartas[0].estado, "SP");
    strcpy(cartas[0].codigo, "A01");
    strcpy(cartas[0].nomeCidade, "Sao Paulo");
    cartas[0].populacao = 12300000LL;
    cartas[0].area = 1521.11;
    cartas[0].pib = 699000000000.0; /* ex: 699 bilhões */
    cartas[0].pontosTuristicos = 30;
    calculaDerivados(&cartas[0]);

    strcpy(cartas[1].estado, "RJ");
    strcpy(cartas[1].codigo, "A02");
    strcpy(cartas[1].nomeCidade, "Rio de Janeiro");
    cartas[1].populacao = 6748000LL;
    cartas[1].area = 1182.30;
    cartas[1].pib = 462000000000.0;
    cartas[1].pontosTuristicos = 25;
    calculaDerivados(&cartas[1]);

    strcpy(cartas[2].estado, "MG");
    strcpy(cartas[2].codigo, "A03");
    strcpy(cartas[2].nomeCidade, "Belo Horizonte");
    cartas[2].populacao = 2523000LL;
    cartas[2].area = 331.40;
    cartas[2].pib = 112000000000.0;
    cartas[2].pontosTuristicos = 18;
    calculaDerivados(&cartas[2]);

    strcpy(cartas[3].estado, "RS");
    strcpy(cartas[3].codigo, "A04");
    strcpy(cartas[3].nomeCidade, "Porto Alegre");
    cartas[3].populacao = 1488000LL;
    cartas[3].area = 496.82;
    cartas[3].pib = 85000000000.0;
    cartas[3].pontosTuristicos = 15;
    calculaDerivados(&cartas[3]);

    strcpy(cartas[4].estado, "PR");
    strcpy(cartas[4].codigo, "B01");
    strcpy(cartas[4].nomeCidade, "Curitiba");
    cartas[4].populacao = 1966000LL;
    cartas[4].area = 435.04;
    cartas[4].pib = 105000000000.0;
    cartas[4].pontosTuristicos = 20;
    calculaDerivados(&cartas[4]);

    strcpy(cartas[5].estado, "BA");
    strcpy(cartas[5].codigo, "B02");
    strcpy(cartas[5].nomeCidade, "Salvador");
    cartas[5].populacao = 2887000LL;
    cartas[5].area = 692.81;
    cartas[5].pib = 97000000000.0;
    cartas[5].pontosTuristicos = 22;
    calculaDerivados(&cartas[5]);

    strcpy(cartas[6].estado, "PE");
    strcpy(cartas[6].codigo, "B03");
    strcpy(cartas[6].nomeCidade, "Recife");
    cartas[6].populacao = 1653000LL;
    cartas[6].area = 218.84;
    cartesafe: ; /* placeholder to avoid stray label - not used */
    cartas[6].pib = 88000000000.0;
    cartas[6].pontosTuristicos = 17;
    calculaDerivados(&cartas[6]);

    strcpy(cartas[7].estado, "CE");
    strcpy(cartas[7].codigo, "B04");
    strcpy(cartas[7].nomeCidade, "Fortaleza");
    cartas[7].populacao = 2687000LL;
    cartas[7].area = 314.93;
    cartas[7].pib = 98000000000.0;
    cartas[7].pontosTuristicos = 19;
    calculaDerivados(&cartas[7]);

    /* Nota: os valores acima são de exemplo / adaptados. */
}

/* Calcula densidade e PIB per capita com proteção contra divisão por zero */
void calculaDerivados(Carta *c) {
    if (c->area <= 0.0) c->densidade = 0.0;
    else c->densidade = (double)c->populacao / c->area;

    if (c->populacao <= 0) c->pibPerCapita = 0.0;
    else c->pibPerCapita = c->pib / (double)c->populacao;
}

/* Exibe um resumo de carta (índice para seleção pelo usuário) */
void exibeCartaResumo(const Carta *c, int index) {
    printf("[%d] %s (%s) - Pop: %lld, Area: %.2f km2, PIB: %.2f bi\n",
           index + 1, c->nomeCidade, c->estado, c->populacao, c->area, c->pib / 1e9);
}

/* Exibe todas as cartas carregadas */
void exibeTodasCartas(const Carta cartas[], int n) {
    printf("\nCartas disponiveis:\n");
    for (int i = 0; i < n; ++i) {
        exibeCartaResumo(&cartas[i], i);
    }
    printf("\n");
}

/* Retorna o nome legível do atributo para exibição */
const char* nomeAtributo(int a) {
    switch (a) {
        case ATR_POPULACAO: return "Populacao";
        case ATR_AREA: return "Area (km2)";
        case ATR_PIB: return "PIB";
        case ATR_PONTOS_TURISTICOS: return "Pontos Turisticos";
        case ATR_DENSIDADE: return "Densidade Populacional";
        case ATR_PIB_PER_CAPITA: return "PIB per Capita";
        default: return "Desconhecido";
    }
}

/* Retorna o valor do atributo como double (facilita soma e comparações) */
double valorAtributoDouble(const Carta *c, int a) {
    switch (a) {
        case ATR_POPULACAO: return (double)c->populacao;
        case ATR_AREA: return c->area;
        case ATR_PIB: return c->pib;
        case ATR_PONTOS_TURISTICOS: return (double)c->pontosTuristicos;
        case ATR_DENSIDADE: return c->densidade;
        case ATR_PIB_PER_CAPITA: return c->pibPerCapita;
        default: return 0.0;
    }
}

/* Compara um atributo entre duas cartas:
   retorna 1 se carta1 vence, 2 se carta2 vence, 0 se empate.
   Respeita a regra: densidade -> menor vence; demais -> maior vence. */
int comparaUmAtributo(const Carta *c1, const Carta *c2, int a) {
    double v1 = valorAtributoDouble(c1, a);
    double v2 = valorAtributoDouble(c2, a);

    if (a == ATR_DENSIDADE) {
        if (v1 < v2) return 1;
        else if (v2 < v1) return 2;
        else return 0;
    } else {
        if (v1 > v2) return 1;
        else if (v2 > v1) return 2;
        else return 0;
    }
}

/* Lê inteiro com validação mínima (retorna valor lido entre min e max) */
int leInteiroSeguro(const char *prompt, int min, int max) {
    int x;
    while (1) {
        printf("%s", prompt);
        if (scanf("%d", &x) != 1) {
            /* entrada inválida: limpa buffer e tenta novamente */
            limpaEntrada();
            printf("Entrada invalida. Tente novamente.\n");
            continue;
        }
        limpaEntrada();
        if (x < min || x > max) {
            printf("Valor fora do intervalo [%d - %d]. Tente novamente.\n", min, max);
            continue;
        }
        return x;
    }
}

/* Limpa buffer de stdin (consome até newline) */
void limpaEntrada() {
    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF) { /* descarta */ }
}

/* Exibe menu de atributos, mas apenas as opções marcadas como disponíveis em 'disponiveis' */
void exibeMenuAtributosDisponiveis(const int disponiveis[]) {
    printf("Escolha um atributo para comparacao:\n");
    if (disponiveis[ATR_POPULACAO]) printf(" 1 - Populacao\n");
    if (disponiveis[ATR_AREA]) printf(" 2 - Area\n");
    if (disponiveis[ATR_PIB]) printf(" 3 - PIB\n");
    if (disponiveis[ATR_PONTOS_TURISTICOS]) printf(" 4 - Pontos Turisticos\n");
    if (disponiveis[ATR_DENSIDADE]) printf(" 5 - Densidade Populacional\n");
    if (disponiveis[ATR_PIB_PER_CAPITA]) printf(" 6 - PIB per Capita\n");
    printf(" 0 - Cancelar\n");
}

/* -------------------------
   Função principal (modo mestre)
   ------------------------- */
int main(void) {
    Carta cartas[MAX_CARTAS];
    int nCartas = 0;
    carregaCartasPadrao(cartas, &nCartas);

    printf("=========================================================\n");
    printf("         SUPER TRUNFO - MODO MESTRE (TechNova)\n");
    printf("=========================================================\n");

    /* Exibe cartas e permite escolher duas para comparar */
    exibeTodasCartas(cartas, nCartas);

    int idx1 = leInteiroSeguro("Escolha a carta 1 (numero): ", 1, nCartas) - 1;
    int idx2 = leInteiroSeguro("Escolha a carta 2 (numero, diferente da carta 1): ", 1, nCartas) - 1;

    while (idx2 == idx1) {
        printf("A carta 2 deve ser diferente da carta 1. Escolha novamente.\n");
        idx2 = leInteiroSeguro("Carta 2: ", 1, nCartas) - 1;
    }

    Carta *c1 = &cartas[idx1];
    Carta *c2 = &cartas[idx2];

    printf("\nComparando: %s (%s)  VS  %s (%s)\n\n",
           c1->nomeCidade, c1->estado, c2->nomeCidade, c2->estado);

    /* Menus dinâmicos: o primeiro atributo escolhido fica indisponível para o segundo */
    int disponiveis[7] = {0,1,1,1,1,1,1}; /* índices 1..6 válidos (0 usado para cancelar) */

    /* Escolha do primeiro atributo */
    int escolha1 = -1;
    while (1) {
        exibeMenuAtributosDisponiveis(disponiveis);
        escolha1 = leInteiroSeguro("Digite o numero do primeiro atributo: ", 0, 6);
        if (escolha1 == 0) {
            printf("Operacao cancelada. Encerrando.\n");
            return 0;
        }
        if (disponiveis[escolha1]) {
            disponiveis[escolha1] = 0; /* remove para segunda escolha */
            break;
        } else {
            printf("Opcao invalida ou indisponivel. Tente novamente.\n");
        }
    }

    /* Escolha do segundo atributo (não pode ser o mesmo do primeiro) */
    int escolha2 = -1;
    while (1) {
        exibeMenuAtributosDisponiveis(disponiveis);
        escolha2 = leInteiroSeguro("Digite o numero do segundo atributo: ", 0, 6);
        if (escolha2 == 0) {
            printf("Operacao cancelada. Encerrando.\n");
            return 0;
        }
        if (disponiveis[escolha2]) {
            break;
        } else {
            printf("Opcao invalida ou indisponivel. Tente novamente.\n");
        }
    }

    /* Exibe atributos escolhidos de forma clara */
    printf("\nAtributos escolhidos:\n  1) %s\n  2) %s\n\n", nomeAtributo(escolha1), nomeAtributo(escolha2));

    /* Comparações individuais */
    printf("---- Comparacao individual: %s ----\n", nomeAtributo(escolha1));
    double v1_a1 = valorAtributoDouble(c1, escolha1);
    double v2_a1 = valorAtributoDouble(c2, escolha1);
    printf("%s: %.6g\n", c1->nomeCidade, v1_a1);
    printf("%s: %.6g\n", c2->nomeCidade, v2_a1);
    int vencedorA1 = comparaUmAtributo(c1, c2, escolha1);
    if (vencedorA1 == 1) printf("-> Vencedor (atributo 1): %s\n\n", c1->nomeCidade);
    else if (vencedorA1 == 2) printf("-> Vencedor (atributo 1): %s\n\n", c2->nomeCidade);
    else printf("-> Empate no atributo 1!\n\n");

    printf("---- Comparacao individual: %s ----\n", nomeAtributo(escolha2));
    double v1_a2 = valorAtributoDouble(c1, escolha2);
    double v2_a2 = valorAtributoDouble(c2, escolha2);
    printf("%s: %.6g\n", c1->nomeCidade, v1_a2);
    printf("%s: %.6g\n", c2->nomeCidade, v2_a2);
    int vencedorA2 = comparaUmAtributo(c1, c2, escolha2);
    if (vencedorA2 == 1) printf("-> Vencedor (atributo 2): %s\n\n", c1->nomeCidade);
    else if (vencedorA2 == 2) printf("-> Vencedor (atributo 2): %s\n\n", c2->nomeCidade);
    else printf("-> Empate no atributo 2!\n\n");

    /* Soma dos valores dos dois atributos para cada carta.
       Observacao: somamos os valores numéricos puros (densidade e pibPerCapita
       são valores menores numericamente, mas o enunciado pede soma direta). */
    double somaC1 = v1_a1 + v1_a2;
    double somaC2 = v2_a1 + v2_a2;

    printf("---- Soma dos atributos ----\n");
    printf("%s: %.6g\n", c1->nomeCidade, somaC1);
    printf("%s: %.6g\n", c2->nomeCidade, somaC2);

    /* Decisão final */
    if (somaC1 > somaC2) {
        printf("\nResultado Final: %s venceu por maior soma (%.6g > %.6g).\n", c1->nomeCidade, somaC1, somaC2);
    } else if (somaC2 > somaC1) {
        printf("\nResultado Final: %s venceu por maior soma (%.6g > %.6g).\n", c2->nomeCidade, somaC2, somaC1);
    } else {
        /* Soma igual -> desempate: contar número de vitórias em atributos individuais */
        int vit1 = 0, vit2 = 0;
        if (vencedorA1 == 1) vit1++; else if (vencedorA1 == 2) vit2++;
        if (vencedorA2 == 1) vit1++; else if (vencedorA2 == 2) vit2++;

        /* Usa operador ternário para construir uma mensagem curta */
        const char *mensagemDesempate = (vit1 > vit2) ? "Carta 1 venceu no desempate por atributos ganhos."
                                    : (vit2 > vit1) ? "Carta 2 venceu no desempate por atributos ganhos."
                                    : "Empate! Soma igual e mesmo número de atributos ganhos.";

        printf("\nSoma igual: %s\n", mensagemDesempate);
    }

    printf("\nObrigado por jogar - TechNova Games © 2025\n");
    printf("=========================================================\n");

    return 0;
}
